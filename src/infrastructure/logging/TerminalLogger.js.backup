/**
 * ÌÑ∞ÎØ∏ÎÑê Î°úÍ∑∏ Í¥ÄÎ¶¨ ÏãúÏä§ÌÖú
 * - Î™®Îì† console Ï∂úÎ†•ÏùÑ JSON ÌååÏùºÎ°ú Ï†ÄÏû•
 * - 48ÏãúÍ∞Ñ Í≤ΩÍ≥ºÌïú Î°úÍ∑∏ ÌååÏùº ÏûêÎèô ÏÇ≠Ï†ú
 */

const fs = require('fs').promises;
const fsSync = require('fs');
const path = require('path');
const chalk = require('chalk');
const util = require('util');

class TerminalLogger {
  constructor(config = {}) {
    this.config = {
      logDir: config.logDir || path.join(process.cwd(), 'logs', 'terminal'),
      maxAge: config.maxAge || 48 * 60 * 60 * 1000, // 48ÏãúÍ∞Ñ (Î∞ÄÎ¶¨Ï¥à)
      checkInterval: config.checkInterval || 60 * 60 * 1000, // 1ÏãúÍ∞ÑÎßàÎã§ Ï≤¥ÌÅ¨
      enabled: config.enabled !== false,
      ...config
    };
    
    this.logBuffer = [];
    this.currentLogFile = null;
    this.originalConsole = {};
    this.cleanupInterval = null;
    
    if (this.config.enabled) {
      this.initialize();
    }
  }

  /**
   * Ï¥àÍ∏∞Ìôî
   */
  async initialize() {
    try {
      // Î°úÍ∑∏ ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
      await this.ensureLogDirectory();
      
      // ÌòÑÏû¨ ÏÑ∏ÏÖòÏùò Î°úÍ∑∏ ÌååÏùº ÏÉùÏÑ±
      this.currentLogFile = await this.createLogFile();
      
      // console Î©îÏÑúÎìú Ïò§Î≤ÑÎùºÏù¥Îìú
      this.overrideConsole();
      
      // Ï†ïÍ∏∞Ï†ÅÏù∏ ÌÅ¥Î¶∞ÏóÖ ÏãúÏûë
      this.startCleanupSchedule();
      
      // Ï¥àÍ∏∞ Î°úÍ∑∏ Í∏∞Î°ù
      await this.writeLog({
        type: 'SYSTEM',
        level: 'info',
        message: 'ÌÑ∞ÎØ∏ÎÑê Î°úÍπÖ ÏãúÏä§ÌÖú ÏãúÏûë',
        timestamp: new Date().toISOString(),
        sessionId: this.getSessionId()
      });
      
      const logFileName = path.basename(this.currentLogFile);
      const logFilePath = path.relative(process.cwd(), this.currentLogFile);
      
      console.log(chalk.green('‚úÖ ÌÑ∞ÎØ∏ÎÑê Î°úÍπÖ ÏãúÏä§ÌÖú ÌôúÏÑ±Ìôî'));
      console.log(chalk.cyan('üìù ÌòÑÏû¨ ÏÑ∏ÏÖò Î°úÍ∑∏:'));
      console.log(chalk.white.bold(`   ${logFileName}`));
      console.log(chalk.gray(`   Í≤ΩÎ°ú: ${logFilePath}`));
      console.log(chalk.gray(`   ÎîîÎ†âÌÜ†Î¶¨: ${this.config.logDir}`));
      
    } catch (error) {
      console.error('ÌÑ∞ÎØ∏ÎÑê Î°úÍ±∞ Ï¥àÍ∏∞Ìôî Ïã§Ìå®:', error);
    }
  }

  /**
   * Î°úÍ∑∏ ÎîîÎ†âÌÜ†Î¶¨ ÌôïÏù∏ Î∞è ÏÉùÏÑ±
   */
  async ensureLogDirectory() {
    try {
      await fs.access(this.config.logDir);
    } catch {
      await fs.mkdir(this.config.logDir, { recursive: true });
    }
  }

  /**
   * Î°úÍ∑∏ ÌååÏùº ÏÉùÏÑ±
   */
  async createLogFile() {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const sessionId = this.getSessionId();
    const filename = `terminal-log-${timestamp}-${sessionId}.json`;
    const filepath = path.join(this.config.logDir, filename);
    
    // Ï¥àÍ∏∞ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏûëÏÑ±
    const metadata = {
      version: '1.0.0',
      sessionId: sessionId,
      startTime: new Date().toISOString(),
      pid: process.pid,
      platform: process.platform,
      nodeVersion: process.version,
      cwd: process.cwd(),
      env: {
        USE_MOCK_REPOSITORY: process.env.USE_MOCK_REPOSITORY,
        DEBUG_MODE: process.env.DEBUG_MODE,
        NODE_ENV: process.env.NODE_ENV
      },
      logs: []
    };
    
    await fs.writeFile(filepath, JSON.stringify(metadata, null, 2));
    return filepath;
  }

  /**
   * ÏÑ∏ÏÖò ID ÏÉùÏÑ±
   */
  getSessionId() {
    return Math.random().toString(36).substring(2, 15);
  }

  /**
   * Console Î©îÏÑúÎìú Ïò§Î≤ÑÎùºÏù¥Îìú
   */
  overrideConsole() {
    const methods = ['log', 'info', 'warn', 'error', 'debug'];
    
    methods.forEach(method => {
      // ÏõêÎ≥∏ Î©îÏÑúÎìú Ï†ÄÏû•
      this.originalConsole[method] = console[method];
      
      // ÏÉàÎ°úÏö¥ Î©îÏÑúÎìúÎ°ú ÍµêÏ≤¥
      console[method] = (...args) => {
        // ÏõêÎ≥∏ console Ï∂úÎ†•
        this.originalConsole[method](...args);
        
        // Î°úÍ∑∏ Ï†ÄÏû•
        this.captureLog(method, args);
      };
    });
  }

  /**
   * Î°úÍ∑∏ Ï∫°Ï≤ò Î∞è Ï†ÄÏû•
   */
  async captureLog(level, args) {
    try {
      // Î°úÍ∑∏ Î©îÏãúÏßÄ Ìè¨Îß∑ÌåÖ
      const message = args.map(arg => {
        if (typeof arg === 'object') {
          return util.inspect(arg, { depth: 3, colors: false });
        }
        // chalk ÏÉâÏÉÅ ÏΩîÎìú Ï†úÍ±∞
        return String(arg).replace(/\x1b\[[0-9;]*m/g, '');
      }).join(' ');
      
      // Î°úÍ∑∏ ÏóîÌä∏Î¶¨ ÏÉùÏÑ±
      const logEntry = {
        timestamp: new Date().toISOString(),
        level: level,
        message: message,
        raw: args.map(arg => {
          if (typeof arg === 'object') {
            try {
              return JSON.parse(JSON.stringify(arg));
            } catch {
              return String(arg);
            }
          }
          return arg;
        }),
        stack: this.getCallStack()
      };
      
      // Î≤ÑÌçºÏóê Ï∂îÍ∞Ä
      this.logBuffer.push(logEntry);
      
      // Î≤ÑÌçºÍ∞Ä ÏùºÏ†ï ÌÅ¨Í∏∞ Ïù¥ÏÉÅÏù¥Î©¥ ÌååÏùºÏóê Í∏∞Î°ù
      if (this.logBuffer.length >= 10) {
        await this.flushBuffer();
      }
      
    } catch (error) {
      // Î°úÍπÖ Ïã§Ìå®Îäî Ï°∞Ïö©Ìûà Ï≤òÎ¶¨
      this.originalConsole.error('Î°úÍ∑∏ Ï∫°Ï≤ò Ïã§Ìå®:', error);
    }
  }

  /**
   * Ìò∏Ï∂ú Ïä§ÌÉù Ï†ïÎ≥¥ Ï∂îÏ∂ú
   */
  getCallStack() {
    const stack = new Error().stack;
    const lines = stack.split('\n').slice(4, 6); // Í¥ÄÎ†® ÏûàÎäî Î∂ÄÎ∂ÑÎßå Ï∂îÏ∂ú
    return lines.map(line => line.trim()).filter(line => 
      !line.includes('TerminalLogger') && 
      !line.includes('node_modules')
    );
  }

  /**
   * Î≤ÑÌçº ÌîåÎü¨Ïãú
   */
  async flushBuffer() {
    if (this.logBuffer.length === 0 || !this.currentLogFile) return;
    
    try {
      // ÌòÑÏû¨ ÌååÏùº ÎÇ¥Ïö© ÏùΩÍ∏∞
      const content = await fs.readFile(this.currentLogFile, 'utf-8');
      const data = JSON.parse(content);
      
      // Î°úÍ∑∏ Ï∂îÍ∞Ä
      data.logs.push(...this.logBuffer);
      data.lastUpdate = new Date().toISOString();
      
      // ÌååÏùºÏóê Ïì∞Í∏∞
      await fs.writeFile(this.currentLogFile, JSON.stringify(data, null, 2));
      
      // Î≤ÑÌçº Ï¥àÍ∏∞Ìôî
      this.logBuffer = [];
      
    } catch (error) {
      this.originalConsole.error('Î°úÍ∑∏ ÌîåÎü¨Ïãú Ïã§Ìå®:', error);
    }
  }

  /**
   * ÎèôÍ∏∞Ï†Å Î≤ÑÌçº ÌîåÎü¨Ïãú (Í∞ïÏ†ú Ï¢ÖÎ£å Ïãú ÏÇ¨Ïö©)
   */
  flushBufferSync() {
    if (this.logBuffer.length === 0 || !this.currentLogFile) return;
    
    try {
      // ÌòÑÏû¨ ÌååÏùº ÎÇ¥Ïö© ÏùΩÍ∏∞ (ÎèôÍ∏∞)
      const content = fsSync.readFileSync(this.currentLogFile, 'utf-8');
      const data = JSON.parse(content);
      
      // Î°úÍ∑∏ Ï∂îÍ∞Ä
      data.logs.push(...this.logBuffer);
      data.lastUpdate = new Date().toISOString();
      data.forceSaved = true; // Í∞ïÏ†ú Ï†ÄÏû• ÌëúÏãú
      
      // ÌååÏùºÏóê Ïì∞Í∏∞ (ÎèôÍ∏∞)
      fsSync.writeFileSync(this.currentLogFile, JSON.stringify(data, null, 2));
      
      // Î≤ÑÌçº Ï¥àÍ∏∞Ìôî
      this.logBuffer = [];
      
      if (this.originalConsole) {
        this.originalConsole.log(chalk.green('‚úÖ Î°úÍ∑∏ Í∞ïÏ†ú Ï†ÄÏû• ÏôÑÎ£å'));
      }
      
    } catch (error) {
      if (this.originalConsole) {
        this.originalConsole.error('ÎèôÍ∏∞ Î°úÍ∑∏ ÌîåÎü¨Ïãú Ïã§Ìå®:', error);
      }
    }
  }

  /**
   * Î°úÍ∑∏ ÏßÅÏ†ë Í∏∞Î°ù
   */
  async writeLog(logData) {
    try {
      if (!this.currentLogFile) return;
      
      const content = await fs.readFile(this.currentLogFile, 'utf-8');
      const data = JSON.parse(content);
      
      data.logs.push({
        timestamp: new Date().toISOString(),
        ...logData
      });
      
      await fs.writeFile(this.currentLogFile, JSON.stringify(data, null, 2));
      
    } catch (error) {
      this.originalConsole.error('Î°úÍ∑∏ Ïì∞Í∏∞ Ïã§Ìå®:', error);
    }
  }

  /**
   * Ï†ïÍ∏∞ ÌÅ¥Î¶∞ÏóÖ Ïä§ÏºÄÏ§Ñ ÏãúÏûë
   */
  startCleanupSchedule() {
    // Ï¶âÏãú Ìïú Î≤à Ïã§Ìñâ
    this.cleanupOldLogs();
    
    // Ï†ïÍ∏∞Ï†ÅÏúºÎ°ú Ïã§Ìñâ
    this.cleanupInterval = setInterval(() => {
      this.cleanupOldLogs();
    }, this.config.checkInterval);
  }

  /**
   * Ïò§ÎûòÎêú Î°úÍ∑∏ ÌååÏùº ÏÇ≠Ï†ú
   */
  async cleanupOldLogs() {
    try {
      const files = await fs.readdir(this.config.logDir);
      const now = Date.now();
      let deletedCount = 0;
      
      for (const file of files) {
        // terminal-logÎ°ú ÏãúÏûëÌïòÎäî JSON ÌååÏùºÎßå Ï≤òÎ¶¨
        if (!file.startsWith('terminal-log-') || !file.endsWith('.json')) {
          continue;
        }
        
        const filepath = path.join(this.config.logDir, file);
        const stats = await fs.stat(filepath);
        const age = now - stats.mtimeMs;
        
        // 48ÏãúÍ∞Ñ Í≤ΩÍ≥ºÌïú ÌååÏùº ÏÇ≠Ï†ú
        if (age > this.config.maxAge) {
          await fs.unlink(filepath);
          deletedCount++;
          this.originalConsole.log(chalk.gray(`üóëÔ∏è Ïò§ÎûòÎêú Î°úÍ∑∏ ÏÇ≠Ï†ú: ${file}`));
        }
      }
      
      if (deletedCount > 0) {
        await this.writeLog({
          type: 'CLEANUP',
          level: 'info',
          message: `${deletedCount}Í∞úÏùò Ïò§ÎûòÎêú Î°úÍ∑∏ ÌååÏùº ÏÇ≠Ï†úÎê®`,
          timestamp: new Date().toISOString()
        });
      }
      
    } catch (error) {
      this.originalConsole.error('Î°úÍ∑∏ ÌÅ¥Î¶∞ÏóÖ Ïã§Ìå®:', error);
    }
  }

  /**
   * Ï¢ÖÎ£å Ï≤òÎ¶¨
   */
  async shutdown() {
    try {
      console.log(chalk.yellow('üìù ÌÑ∞ÎØ∏ÎÑê Î°úÍ±∞ Ï¢ÖÎ£å Ï§ë...'));
      
      // ÎßàÏßÄÎßâ Î≤ÑÌçº ÌîåÎü¨Ïãú
      await this.flushBuffer();
      
      // Ï¢ÖÎ£å Î°úÍ∑∏ Í∏∞Î°ù
      await this.writeLog({
        type: 'SYSTEM',
        level: 'info',
        message: 'ÌÑ∞ÎØ∏ÎÑê Î°úÍπÖ ÏãúÏä§ÌÖú Ï¢ÖÎ£å',
        timestamp: new Date().toISOString(),
        sessionId: this.getSessionId()
      });
      
      // ÌÅ¥Î¶∞ÏóÖ Ïù∏ÌÑ∞Î≤å Ï†ïÎ¶¨
      if (this.cleanupInterval) {
        clearInterval(this.cleanupInterval);
      }
      
      // console ÏõêÎ≥µ
      this.restoreConsole();
      
      // Î°úÍ∑∏ ÌååÏùº Í≤ΩÎ°ú ÌëúÏãú
      if (this.currentLogFile) {
        const logFileName = path.basename(this.currentLogFile);
        const logFilePath = path.relative(process.cwd(), this.currentLogFile);
        console.log(chalk.green('‚úÖ ÌÑ∞ÎØ∏ÎÑê Î°úÍ±∞ Ï¢ÖÎ£å ÏôÑÎ£å'));
        console.log(chalk.cyan('üìÅ Î°úÍ∑∏ ÌååÏùº Ï†ÄÏû•Îê®:'));
        console.log(chalk.white.bold(`   ${logFileName}`));
        console.log(chalk.gray(`   Í≤ΩÎ°ú: ${logFilePath}`));
      } else {
        console.log(chalk.green('‚úÖ ÌÑ∞ÎØ∏ÎÑê Î°úÍ±∞ Ï¢ÖÎ£å ÏôÑÎ£å'));
      }
      
    } catch (error) {
      this.originalConsole.error('ÌÑ∞ÎØ∏ÎÑê Î°úÍ±∞ Ï¢ÖÎ£å Ïã§Ìå®:', error);
    }
  }

  /**
   * Í∞ïÏ†ú Ï¢ÖÎ£å Ï≤òÎ¶¨ (ÎèôÍ∏∞Ï†Å)
   */
  forceShutdown() {
    try {
      if (this.originalConsole) {
        this.originalConsole.log(chalk.yellow('\n‚ö†Ô∏è Í∞ïÏ†ú Ï¢ÖÎ£å Í∞êÏßÄ - Î°úÍ∑∏ Ï†ÄÏû• Ï§ë...'));
      }
      
      // ÎèôÍ∏∞Ï†ÅÏúºÎ°ú Î≤ÑÌçº ÌîåÎü¨Ïãú
      this.flushBufferSync();
      
      // Ï¢ÖÎ£å Î°úÍ∑∏ Í∏∞Î°ù (ÎèôÍ∏∞)
      if (this.currentLogFile) {
        try {
          const content = fsSync.readFileSync(this.currentLogFile, 'utf-8');
          const data = JSON.parse(content);
          data.logs.push({
            timestamp: new Date().toISOString(),
            type: 'SYSTEM',
            level: 'warn',
            message: 'ÌîÑÎ°úÍ∑∏Îû® Í∞ïÏ†ú Ï¢ÖÎ£å (Ctrl+C)',
            forcedExit: true
          });
          data.endTime = new Date().toISOString();
          data.exitType = 'FORCED';
          
          fsSync.writeFileSync(this.currentLogFile, JSON.stringify(data, null, 2));
        } catch (e) {
          // Î¨¥Ïãú
        }
      }
      
      // ÌÅ¥Î¶∞ÏóÖ Ïù∏ÌÑ∞Î≤å Ï†ïÎ¶¨
      if (this.cleanupInterval) {
        clearInterval(this.cleanupInterval);
      }
      
      // console ÏõêÎ≥µ
      this.restoreConsole();
      
      // Î°úÍ∑∏ ÌååÏùº Í≤ΩÎ°ú ÌëúÏãú
      if (this.originalConsole && this.currentLogFile) {
        const logFileName = path.basename(this.currentLogFile);
        const logFilePath = path.relative(process.cwd(), this.currentLogFile);
        this.originalConsole.log(chalk.green('‚úÖ Î°úÍ∑∏ Ï†ÄÏû• ÏôÑÎ£å'));
        this.originalConsole.log(chalk.red.bold('üö® Í∞ïÏ†ú Ï¢ÖÎ£å Î°úÍ∑∏:'));
        this.originalConsole.log(chalk.white.bold(`   ${logFileName}`));
        this.originalConsole.log(chalk.gray(`   Í≤ΩÎ°ú: ${logFilePath}`));
      } else if (this.originalConsole) {
        this.originalConsole.log(chalk.green('‚úÖ Î°úÍ∑∏ Ï†ÄÏû• ÏôÑÎ£å'));
      }
      
    } catch (error) {
      if (this.originalConsole) {
        this.originalConsole.error('Í∞ïÏ†ú Ï¢ÖÎ£å Ï≤òÎ¶¨ Ïã§Ìå®:', error);
      }
    }
  }

  /**
   * Console ÏõêÎ≥µ
   */
  restoreConsole() {
    Object.keys(this.originalConsole).forEach(method => {
      console[method] = this.originalConsole[method];
    });
  }

  /**
   * ÌòÑÏû¨ ÏÑ∏ÏÖò Î°úÍ∑∏ Ï°∞Ìöå
   */
  async getCurrentLogs() {
    try {
      if (!this.currentLogFile) return null;
      
      const content = await fs.readFile(this.currentLogFile, 'utf-8');
      return JSON.parse(content);
      
    } catch (error) {
      this.originalConsole.error('Î°úÍ∑∏ Ï°∞Ìöå Ïã§Ìå®:', error);
      return null;
    }
  }

  /**
   * ÌÜµÍ≥Ñ Ï†ïÎ≥¥ Ï°∞Ìöå
   */
  async getStatistics() {
    try {
      const files = await fs.readdir(this.config.logDir);
      const terminalLogs = files.filter(f => 
        f.startsWith('terminal-log-') && f.endsWith('.json')
      );
      
      let totalSize = 0;
      let oldestFile = null;
      let newestFile = null;
      
      for (const file of terminalLogs) {
        const filepath = path.join(this.config.logDir, file);
        const stats = await fs.stat(filepath);
        totalSize += stats.size;
        
        if (!oldestFile || stats.mtimeMs < oldestFile.time) {
          oldestFile = { name: file, time: stats.mtimeMs };
        }
        
        if (!newestFile || stats.mtimeMs > newestFile.time) {
          newestFile = { name: file, time: stats.mtimeMs };
        }
      }
      
      return {
        totalFiles: terminalLogs.length,
        totalSize: (totalSize / 1024 / 1024).toFixed(2) + ' MB',
        oldestFile: oldestFile ? {
          name: oldestFile.name,
          age: this.formatAge(Date.now() - oldestFile.time)
        } : null,
        newestFile: newestFile ? {
          name: newestFile.name,
          age: this.formatAge(Date.now() - newestFile.time)
        } : null,
        currentSession: this.currentLogFile ? path.basename(this.currentLogFile) : null
      };
      
    } catch (error) {
      this.originalConsole.error('ÌÜµÍ≥Ñ Ï°∞Ìöå Ïã§Ìå®:', error);
      return null;
    }
  }

  /**
   * ÏãúÍ∞Ñ Ìè¨Îß∑ÌåÖ
   */
  formatAge(ms) {
    const hours = Math.floor(ms / (1000 * 60 * 60));
    const minutes = Math.floor((ms % (1000 * 60 * 60)) / (1000 * 60));
    
    if (hours > 0) {
      return `${hours}ÏãúÍ∞Ñ ${minutes}Î∂Ñ`;
    }
    return `${minutes}Î∂Ñ`;
  }
}

// Ïã±Í∏ÄÌÜ§ Ïù∏Ïä§ÌÑ¥Ïä§
let terminalLogger = null;

/**
 * ÌÑ∞ÎØ∏ÎÑê Î°úÍ±∞ Ï¥àÍ∏∞Ìôî
 */
function initializeTerminalLogger(config = {}) {
  if (!terminalLogger) {
    terminalLogger = new TerminalLogger(config);
  }
  return terminalLogger;
}

/**
 * ÌÑ∞ÎØ∏ÎÑê Î°úÍ±∞ Ïù∏Ïä§ÌÑ¥Ïä§ Í∞ÄÏ†∏Ïò§Í∏∞
 */
function getTerminalLogger() {
  if (!terminalLogger) {
    terminalLogger = new TerminalLogger();
  }
  return terminalLogger;
}

// ÌîÑÎ°úÏÑ∏Ïä§ Ï¢ÖÎ£å Ïãú Ï≤òÎ¶¨
let isShuttingDown = false;

// Ï†ïÏÉÅ Ï¢ÖÎ£å Ïãú
process.on('exit', (code) => {
  if (terminalLogger && !isShuttingDown) {
    terminalLogger.forceShutdown();
  }
});

// Ctrl+C (SIGINT) Ï≤òÎ¶¨
process.on('SIGINT', () => {
  if (isShuttingDown) {
    // Îëê Î≤àÏß∏ Ctrl+CÎäî Ï¶âÏãú Ï¢ÖÎ£å
    process.exit(1);
  }
  
  isShuttingDown = true;
  
  if (terminalLogger) {
    // ÎèôÍ∏∞Ï†ÅÏúºÎ°ú Ï≤òÎ¶¨
    terminalLogger.forceShutdown();
    
    // ÏïΩÍ∞ÑÏùò ÏßÄÏó∞ ÌõÑ Ï¢ÖÎ£å (ÌååÏùº Ïì∞Í∏∞ ÏôÑÎ£å Î≥¥Ïû•)
    setTimeout(() => {
      process.exit(0);
    }, 100);
  } else {
    process.exit(0);
  }
});

// SIGTERM Ï≤òÎ¶¨ (Docker, PM2 Îì±ÏóêÏÑú ÏÇ¨Ïö©)
process.on('SIGTERM', () => {
  if (isShuttingDown) {
    process.exit(1);
  }
  
  isShuttingDown = true;
  
  if (terminalLogger) {
    terminalLogger.forceShutdown();
    setTimeout(() => {
      process.exit(0);
    }, 100);
  } else {
    process.exit(0);
  }
});

// Windows Ï†ÑÏö© Ï≤òÎ¶¨
if (process.platform === 'win32') {
  const readline = require('readline');
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  
  rl.on('SIGINT', () => {
    process.emit('SIGINT');
  });
}

// ÏòàÍ∏∞Ïπò ÏïäÏùÄ Ï¢ÖÎ£å Ï≤òÎ¶¨
process.on('beforeExit', (code) => {
  if (terminalLogger && !isShuttingDown) {
    isShuttingDown = true;
    terminalLogger.forceShutdown();
  }
});

// Ï≤òÎ¶¨ÎêòÏßÄ ÏïäÏùÄ ÏòàÏô∏ Ï≤òÎ¶¨
process.on('uncaughtException', (error) => {
  if (terminalLogger) {
    try {
      // ÏóêÎü¨Î•º Î°úÍ∑∏Ïóê Í∏∞Î°ù
      if (terminalLogger.currentLogFile) {
        const content = fsSync.readFileSync(terminalLogger.currentLogFile, 'utf-8');
        const data = JSON.parse(content);
        data.logs.push({
          timestamp: new Date().toISOString(),
          type: 'ERROR',
          level: 'error',
          message: `Uncaught Exception: ${error.message}`,
          stack: error.stack,
          fatal: true
        });
        fsSync.writeFileSync(terminalLogger.currentLogFile, JSON.stringify(data, null, 2));
      }
    } catch (e) {
      // Î¨¥Ïãú
    }
    
    terminalLogger.forceShutdown();
  }
  
  // ÏõêÎ≥∏ ÏóêÎü¨ Ï∂úÎ†•
  console.error('Uncaught Exception:', error);
  process.exit(1);
});

module.exports = {
  TerminalLogger,
  initializeTerminalLogger,
  getTerminalLogger
};