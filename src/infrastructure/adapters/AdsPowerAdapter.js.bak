const axios = require('axios');
const puppeteer = require('puppeteer');
const { setupStealthPage, applyAdvancedEvasion } = require('./StealthBrowserSetup');
const { EventEmitter } = require('events');

/**
 * @class AdsPowerAdapter
 * @description AdsPower 브라우저 자동화 어댑터 (자동화 감지 회피 적용)
 */
class AdsPowerAdapter extends EventEmitter {
  constructor(config = {}) {
    super();
    
    // 설정
    this.config = {
      apiUrl: config.apiUrl || process.env.ADSPOWER_API_URL || 'http://local.adspower.net:50325',
      timeout: config.timeout || 30000,
      retryAttempts: config.retryAttempts || 3,
      retryDelay: config.retryDelay || 2000,
      debugMode: config.debugMode || false,
      stealthMode: config.stealthMode !== false // 기본적으로 스텔스 모드 활성화
    };

    // 상태 관리
    this.activeSessions = new Map();
    this.browserInstances = new Map();
    
    // API 클라이언트 설정
    this.apiClient = axios.create({
      baseURL: this.config.apiUrl,
      timeout: this.config.timeout,
      headers: {
        'Content-Type': 'application/json'
      }
    });

    // 인간적인 타이밍 설정
    this.humanTiming = {
      minDelay: 100,
      maxDelay: 3000,
      typingSpeed: { min: 50, max: 150 },
      clickDelay: { min: 50, max: 500 },
      scrollDelay: { min: 100, max: 500 },
      pageLoadDelay: { min: 2000, max: 5000 }
    };
  }

  /**
   * 랜덤 지연 생성 (인간적인 행동 모방)
   */
  getRandomDelay(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  /**
   * 인간적인 지연 적용
   */
  async humanDelay(type = 'default') {
    let delay;
    switch (type) {
      case 'typing':
        delay = this.getRandomDelay(this.humanTiming.typingSpeed.min, this.humanTiming.typingSpeed.max);
        break;
      case 'click':
        delay = this.getRandomDelay(this.humanTiming.clickDelay.min, this.humanTiming.clickDelay.max);
        break;
      case 'scroll':
        delay = this.getRandomDelay(this.humanTiming.scrollDelay.min, this.humanTiming.scrollDelay.max);
        break;
      case 'pageLoad':
        delay = this.getRandomDelay(this.humanTiming.pageLoadDelay.min, this.humanTiming.pageLoadDelay.max);
        break;
      default:
        delay = this.getRandomDelay(this.humanTiming.minDelay, this.humanTiming.maxDelay);
    }
    
    await new Promise(resolve => setTimeout(resolve, delay));
  }

  /**
   * API 연결 확인
   */
  async checkConnection() {
    try {
      const response = await this.apiClient.get('/api/v1/user/list', {
        params: { page_size: 1 }
      });
      return response.data.code === 0;
    } catch (error) {
      this.emit('error', { type: 'connection', error });
      return false;
    }
  }

  /**
   * 프로필 목록 조회
   */
  async getProfiles(options = {}) {
    try {
      const params = {
        page_size: options.pageSize || 100,
        page_no: options.page || 1
      };

      if (options.groupName) params.group_name = options.groupName;
      if (options.searchText) params.search = options.searchText;

      const response = await this.apiClient.get('/api/v1/user/list', { params });
      
      if (response.data.code !== 0) {
        throw new Error(response.data.msg || 'Failed to get profiles');
      }

      return {
        profiles: response.data.data.list || [],
        total: response.data.data.total_count || 0,
        page: response.data.data.page_no || 1,
        pageSize: response.data.data.page_size || params.page_size
      };
    } catch (error) {
      this.emit('error', { type: 'api', method: 'getProfiles', error });
      throw error;
    }
  }

  /**
   * AdsPower API를 통해 브라우저 상태 확인
   */
  async checkBrowserStatus(profileId) {
    try {
      const response = await this.apiClient.get('/api/v1/browser/active', {
        params: { user_id: profileId }
      });
      
      if (response.data.code === 0 && response.data.data) {
        const data = response.data.data;
        // status가 'Active'이고 ws 엔드포인트가 있으면 실행 중
        return {
          isActive: data.status === 'Active',
          wsEndpoint: data.ws?.puppeteer || null,
          debugPort: data.debug_port || null
        };
      }
      
      return { isActive: false };
    } catch (error) {
      this.emit('debug', `브라우저 상태 확인 실패: ${error.message}`);
      return { isActive: false };
    }
  }

  /**
   * 브라우저 실행 (자동화 감지 회피 적용)
   */
  async launchBrowser(profileId, options = {}) {
    try {
      // 1. 먼저 로컬 세션 맵 확인
      if (this.activeSessions.has(profileId)) {
        const session = this.activeSessions.get(profileId);
        if (session.browser && session.browser.isConnected()) {
          this.emit('info', `Profile ${profileId} already running (from local cache)`);
          return session;
        } else {
          // 연결이 끊긴 세션은 정리
          this.activeSessions.delete(profileId);
          this.browserInstances.delete(profileId);
        }
      }

      // 2. AdsPower API를 통해 실제 브라우저 상태 확인
      const browserStatus = await this.checkBrowserStatus(profileId);
      
      if (browserStatus.isActive && browserStatus.wsEndpoint) {
        this.emit('info', `Profile ${profileId} already running (from AdsPower API)`);
        
        try {
          // 기존 브라우저에 재연결 시도
          const browser = await this.connectPuppeteer(browserStatus.wsEndpoint, profileId);
          
          const session = {
            profileId,
            browser,
            wsEndpoint: browserStatus.wsEndpoint,
            debugPort: browserStatus.debugPort,
            startTime: new Date(),
            pages: new Map(),
            reused: true // 재사용된 세션 표시
          };
          
          this.activeSessions.set(profileId, session);
          this.browserInstances.set(profileId, browser);
          
          this.emit('browser:reused', { profileId, session });
          return session;
          
        } catch (reconnectError) {
          this.emit('warning', `기존 브라우저 재연결 실패, 새로 시작: ${reconnectError.message}`);
          // 재연결 실패 시 브라우저 종료 후 새로 시작
          await this.apiClient.get('/api/v1/browser/stop', {
            params: { user_id: profileId }
          }).catch(() => {}); // 종료 실패 무시
        }
      }

      // 3. 새 브라우저 시작
      // GUI와 동일하게 최소 파라미터만 사용 (user_id만)
      const params = {
        user_id: profileId
        // GUI "Open" 버튼과 동일하게 다른 파라미터 생략
        // 프로필 자체 설정값이 사용됨
      };

      // 재시도 로직
      let lastError;
      for (let attempt = 1; attempt <= this.config.retryAttempts; attempt++) {
        try {
          this.emit('info', `Starting browser for profile ${profileId} (attempt ${attempt}/${this.config.retryAttempts})`);
          
          const response = await this.apiClient.get('/api/v1/browser/start', { params });
          
          // 디버그 로깅 추가
          if (this.config.debugMode) {
            console.log('AdsPower API Response:', JSON.stringify(response.data, null, 2));
          }
          
          if (response.data.code !== 0) {
            throw new Error(response.data.msg || 'Failed to launch browser');
          }

          const data = response.data.data;
          
          // Puppeteer 연결 (스텔스 모드 적용)
          const browser = await this.connectPuppeteer(data.ws.puppeteer, profileId);
          
          // 세션 저장
          const session = {
            profileId,
            browser,
            wsEndpoint: data.ws.puppeteer,
            debugPort: data.debug_port,
            webdriver: data.webdriver,
            startTime: new Date(),
            pages: new Map()
          };

          this.activeSessions.set(profileId, session);
          this.browserInstances.set(profileId, browser);

          this.emit('browser:launched', { profileId, session });
          
          return session;
          
        } catch (error) {
          lastError = error;
          this.emit('warning', `Browser launch attempt ${attempt} failed: ${error.message}`);
          
          if (attempt < this.config.retryAttempts) {
            await this.humanDelay();
          }
        }
      }

      throw lastError;
      
    } catch (error) {
      this.emit('error', { type: 'browser:launch', profileId, error });
      throw error;
    }
  }

  /**
   * Puppeteer 연결 (자동화 감지 회피 적용)
   */
  async connectPuppeteer(wsEndpoint, profileId) {
    try {
      // Puppeteer 연결 옵션
      const browser = await puppeteer.connect({
        browserWSEndpoint: wsEndpoint,
        defaultViewport: null,
        slowMo: this.config.stealthMode ? this.getRandomDelay(30, 100) : 0 // 인간적인 속도
      });

      // 모든 페이지에 스텔스 설정 적용
      const pages = await browser.pages();
      for (const page of pages) {
        await setupStealthPage(page); // 개선된 Stealth 설정 사용
        await this.applyStealthSettings(page);
        await this.applyNetworkRandomization(page);
        await applyAdvancedEvasion(page); // 고급 회피 기법 추가
      }

      // 새 페이지 생성 시 자동으로 스텔스 설정 적용
      browser.on('targetcreated', async (target) => {
        if (target.type() === 'page') {
          const page = await target.page();
          if (page) {
            await setupStealthPage(page); // 개선된 Stealth 설정 사용
            await this.applyStealthSettings(page);
            await this.applyNetworkRandomization(page);
            await applyAdvancedEvasion(page); // 고급 회피 기법 추가
          }
        }
      });

      return browser;
      
    } catch (error) {
      this.emit('error', { type: 'puppeteer:connect', profileId, error });
      throw error;
    }
  }

  /**
   * 페이지에 스텔스 설정 적용 (자동화 감지 회피)
   */
  async applyStealthSettings(page) {
    if (!this.config.stealthMode) return;

    try {
      // 1. navigator.webdriver 숨기기
      await page.evaluateOnNewDocument(() => {
        Object.defineProperty(navigator, 'webdriver', {
          get: () => undefined
        });
      });

      // 2. Chrome 자동화 속성 숨기기
      await page.evaluateOnNewDocument(() => {
        window.navigator.chrome = {
          runtime: {},
        };
      });

      // 3. Permissions API 정상화
      await page.evaluateOnNewDocument(() => {
        const originalQuery = window.navigator.permissions.query;
        window.navigator.permissions.query = (parameters) => (
          parameters.name === 'notifications' ?
            Promise.resolve({ state: Notification.permission }) :
            originalQuery(parameters)
        );
      });

      // 4. 플러그인 배열 정상화
      await page.evaluateOnNewDocument(() => {
        Object.defineProperty(navigator, 'plugins', {
          get: () => [
            {0: {name: 'Chrome PDF Plugin', filename: 'internal-pdf-viewer', description: 'Portable Document Format'}},
            {1: {name: 'Chrome PDF Viewer', filename: 'mhjfbmdgcfjbbpaeojofohoefgiehjai', description: ''}},
            {2: {name: 'Native Client', filename: 'internal-nacl-plugin', description: 'Native Client Executable'}}
          ]
        });
      });

      // 5. 언어 설정
      await page.evaluateOnNewDocument(() => {
        Object.defineProperty(navigator, 'languages', {
          get: () => ['ko-KR', 'ko', 'en-US', 'en']
        });
      });

      // 6. WebGL Vendor 정상화
      await page.evaluateOnNewDocument(() => {
        const getParameter = WebGLRenderingContext.prototype.getParameter;
        WebGLRenderingContext.prototype.getParameter = function(parameter) {
          if (parameter === 37445) {
            return 'Intel Inc.';
          }
          if (parameter === 37446) {
            return 'Intel Iris OpenGL Engine';
          }
          return getParameter(parameter);
        };
      });

      // 7. User Agent - AdsPower가 설정한 값 유지
      // 중요: AdsPower의 anti-fingerprinting을 위해 User-Agent 변경하지 않음

      // 8. 시간대 설정
      await page.emulateTimezone('Asia/Seoul');

      // 9. 마우스 움직임 시뮬레이션 활성화
      page.mouse.move(
        this.getRandomDelay(100, 800),
        this.getRandomDelay(100, 600)
      );

      // 10. [AdsPower가 제공] Canvas/WebGL/Audio Fingerprinting은 AdsPower가 프로필별로 관리
      // AdsPower가 각 프로필마다 고유한 Canvas, WebGL, AudioContext 지문을 자동으로 제공하므로
      // 추가 조작이 불필요하며 오히려 충돌을 일으킬 수 있음

      // 11. WebRTC IP 누출 차단
      await page.evaluateOnNewDocument(() => {
        // WebRTC 완전 차단이 아닌 가짜 IP 제공 (더 자연스러움)
        const originalRTCPeerConnection = window.RTCPeerConnection || window.webkitRTCPeerConnection;
        
        if (originalRTCPeerConnection) {
          window.RTCPeerConnection = new Proxy(originalRTCPeerConnection, {
            construct(target, args) {
              const instance = new target(...args);
              
              // createDataChannel 오버라이드
              const originalCreateDataChannel = instance.createDataChannel;
              instance.createDataChannel = function(...args) {
                // 프라이빗 IP 숨기기
                return originalCreateDataChannel.apply(this, args);
              };
              
              // createOffer 오버라이드
              const originalCreateOffer = instance.createOffer;
              instance.createOffer = async function(...args) {
                const offer = await originalCreateOffer.apply(this, args);
                // SDP에서 실제 IP 제거
                if (offer && offer.sdp) {
                  offer.sdp = offer.sdp.replace(/([0-9]{1,3}\.){3}[0-9]{1,3}/g, (match) => {
                    // 로컬 IP 범위면 가짜 IP로 대체
                    if (match.startsWith('192.168.') || match.startsWith('10.') || match.startsWith('172.')) {
                      return '10.0.0.' + Math.floor(Math.random() * 255);
                    }
                    return match;
                  });
                }
                return offer;
              };
              
              return instance;
            }
          });
          
          // MediaDevices 보호
          if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            const originalGetUserMedia = navigator.mediaDevices.getUserMedia;
            navigator.mediaDevices.getUserMedia = function(constraints) {
              // 오디오/비디오 요청 시 가짜 스트림 반환 고려
              if (constraints && (constraints.audio || constraints.video)) {
                return Promise.reject(new DOMException('Permission denied'));
              }
              return originalGetUserMedia.apply(this, arguments);
            };
          }
        }
      });

      // 12. [AdsPower가 제공] AudioContext와 Font Fingerprinting도 AdsPower가 프로필별로 관리
      // AdsPower가 자동으로 처리하므로 추가 코드 불필요

      this.emit('debug', `Advanced stealth settings applied to page`);
      
    } catch (error) {
      this.emit('warning', `Failed to apply some stealth settings: ${error.message}`);
    }
  }

  /**
   * 네트워크 패턴 랜덤화 적용
   */
  async applyNetworkRandomization(page) {
    if (!this.config.stealthMode) return;
    
    // 이미 적용된 경우 건너뛰기
    if (page._networkRandomizationApplied) return;
    page._networkRandomizationApplied = true;

    try {
      // 요청 간격 랜덤화를 위한 큐
      const requestQueue = new Map();
      const requestDelayRange = { min: 50, max: 500 };
      
      // 간단하고 효과적인 요청 인터셉트 설정
      await page.setRequestInterception(true);
      
      page.on('request', async (request) => {
        try {
          const resourceType = request.resourceType();
          
          // 주요 리소스 타입에만 짧은 랜덤 지연 적용
          if (['xhr', 'fetch', 'script', 'stylesheet'].includes(resourceType)) {
            // 50-200ms 사이의 짧은 랜덤 지연
            const delay = this.getRandomDelay(50, 200);
            await new Promise(resolve => setTimeout(resolve, delay));
          }
          
          // 헤더는 AdsPower가 프로필별로 관리하므로 수정하지 않음
          // 단순히 요청 계속 진행
          if (!request.isInterceptResolutionHandled()) {
            request.continue();
          }
          
        } catch (error) {
          // 오류 시 요청 계속 진행
          if (!request.isInterceptResolutionHandled()) {
            request.continue();
          }
        }
      });
      
      // 응답 타이밍 랜덤화
      page.on('response', async (response) => {
        // 응답 처리에도 약간의 지연 추가
        const delay = this.getRandomDelay(10, 50);
        await new Promise(resolve => setTimeout(resolve, delay));
      });
      
      // 페이지 내 타이밍 랜덤화 (간단하게)
      await page.evaluateOnNewDocument(() => {
        // fetch와 XHR에 짧은 랜덤 지연 추가
        const originalFetch = window.fetch;
        window.fetch = function(...args) {
          return new Promise((resolve, reject) => {
            // 10-100ms 사이의 짧은 지연
            const delay = 10 + Math.random() * 90;
            setTimeout(() => {
              originalFetch.apply(this, args).then(resolve).catch(reject);
            }, delay);
          });
        };
      });
      
      this.emit('debug', 'Network randomization applied to page');
      
    } catch (error) {
      this.emit('warning', `Failed to apply network randomization: ${error.message}`);
    }
  }

  /**
   * 페이지 생성 또는 가져오기
   */
  async getPage(profileId, url = null) {
    const session = this.activeSessions.get(profileId);
    if (!session) {
      throw new Error(`No active session for profile ${profileId}`);
    }

    let page;
    
    // 기존 페이지 확인
    const pages = await session.browser.pages();
    if (pages.length > 0) {
      page = pages[0];
    } else {
      page = await session.browser.newPage();
    }

    // 스텔스 설정 적용
    await this.applyStealthSettings(page);
    
    // 네트워크 랜덤화 적용
    await this.applyNetworkRandomization(page);

    // about:blank에서 시작하는 경우 YouTube로 이동
    const currentUrl = page.url();
    if (currentUrl === 'about:blank' || currentUrl === '') {
      this.emit('debug', 'Page is at about:blank, navigating to YouTube...');
      await this.navigateWithRetry(page, 'https://www.youtube.com');
      await page.waitForTimeout(3000); // 페이지 로드 대기
    }
    
    // URL로 이동 (지정된 경우)
    if (url && url !== currentUrl) {
      await this.navigateWithRetry(page, url);
    }

    // 세션에 페이지 저장 (안전한 방식으로)
    try {
      const pageId = page.target()._targetId || `page_${Date.now()}`;
      session.pages.set(pageId, page);
    } catch (e) {
      // 페이지 ID 저장 실패 시 무시
      this.emit('debug', 'Could not store page ID, continuing...');
    }

    return page;
  }

  /**
   * 안전한 페이지 네비게이션 (재시도 로직 포함)
   */
  async navigateWithRetry(page, url, options = {}) {
    const maxAttempts = options.maxAttempts || 3;
    let lastError;

    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      try {
        this.emit('debug', `Navigating to ${url} (attempt ${attempt}/${maxAttempts})`);
        
        await page.goto(url, {
          waitUntil: options.waitUntil || 'networkidle2',
          timeout: options.timeout || 30000
        });

        // 페이지 로드 후 인간적인 지연
        await this.humanDelay('pageLoad');
        
        return true;
        
      } catch (error) {
        lastError = error;
        this.emit('warning', `Navigation attempt ${attempt} failed: ${error.message}`);
        
        if (attempt < maxAttempts) {
          await this.humanDelay();
        }
      }
    }

    throw lastError;
  }

  /**
   * 브라우저 종료
   */
  async closeBrowser(profileId, forceClose = false) {
    try {
      // Puppeteer 브라우저 연결 해제
      const session = this.activeSessions.get(profileId);
      if (session && session.browser) {
        try {
          await session.browser.disconnect();
        } catch (disconnectError) {
          this.emit('debug', `브라우저 연결 해제 실패 (무시): ${disconnectError.message}`);
        }
      }

      // AdsPower API로 브라우저 종료
      const response = await this.apiClient.get('/api/v1/browser/stop', {
        params: { user_id: profileId }
      });

      // 세션 정리 (항상 실행)
      this.activeSessions.delete(profileId);
      this.browserInstances.delete(profileId);

      this.emit('browser:closed', { profileId });
      
      return response.data.code === 0;
      
    } catch (error) {
      // 오류가 발생해도 세션 정리는 수행
      this.activeSessions.delete(profileId);
      this.browserInstances.delete(profileId);
      
      this.emit('error', { type: 'browser:close', profileId, error });
      return false;
    }
  }

  /**
   * 모든 브라우저 종료
   */
  async closeAllBrowsers() {
    const results = [];
    
    for (const [profileId] of this.activeSessions) {
      const result = await this.closeBrowser(profileId);
      results.push({ profileId, success: result });
    }

    return results;
  }

  /**
   * 활성 세션 상태 확인
   */
  getActiveSessionsInfo() {
    const info = [];
    
    for (const [profileId, session] of this.activeSessions) {
      info.push({
        profileId,
        startTime: session.startTime,
        isConnected: session.browser.isConnected(),
        pagesCount: session.pages.size,
        duration: Date.now() - session.startTime.getTime()
      });
    }

    return info;
  }

  /**
   * 리소스 정리
   */
  async cleanup() {
    await this.closeAllBrowsers();
    this.removeAllListeners();
  }
}

module.exports = AdsPowerAdapter;